name: PR Review Requested â†’ Slack DMs (individual & team)

on:
  pull_request:
    types: [review_requested]

permissions:
  contents: read
  pull-requests: read

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (for users.yml)
        uses: actions/checkout@v4

      - name: Fan-out Slack DMs
        uses: actions/github-script@v7
        env:
          ORG: ${{ secrets.ORG }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          ORG_READ_TOKEN: ${{ secrets.ORG_READ_TOKEN }} # optional but recommended
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const { default: fetch } = await import('node-fetch');

            // -------- helpers --------
            const pr = context.payload.pull_request;
            const act = context.payload.action;
            const requestedReviewer = context.payload.requested_reviewer || null;
            const requestedTeam = context.payload.requested_team || null;
            const org = process.env.ORG || context.repo.owner;

            function loadMapping() {
              const path = '.github/pr-reminder/users.yml';
              if (!fs.existsSync(path)) return { users: [] };
              return yaml.load(fs.readFileSync(path, 'utf8')) || { users: [] };
            }

            const mapping = loadMapping();
            const mapByGithub = new Map(
              (mapping.users || []).map(u => [String(u.github).toLowerCase(), u])
            );

            async function slackLookupByEmail(email) {
              if (!email) return null;
              const res = await fetch('https://slack.com/api/users.lookupByEmail', {
                method: 'GET',
                headers: { 'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}` },
              //  URL params appended:
              });
              // node-fetch GET with params: easier to build URL:
              return null;
            }

            // utility: GET with query params
            async function httpGet(url, headers = {}, params = {}) {
              const qs = new URLSearchParams(params);
              const full = qs.toString() ? `${url}?${qs.toString()}` : url;
              const res = await fetch(full, { headers });
              if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
              return await res.json();
            }

            async function slackLookupByEmail2(email) {
              try {
                const data = await httpGet(
                  'https://slack.com/api/users.lookupByEmail',
                  { 'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}` },
                  { email }
                );
                if (data.ok && data.user && data.user.id) return data.user.id;
              } catch (e) {}
              return null;
            }

            async function slackDM(userId, blocks, fallbackText='PR review requested') {
              const res = await fetch('https://slack.com/api/chat.postMessage', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}`,
                  'Content-Type': 'application/json; charset=utf-8'
                },
                body: JSON.stringify({
                  channel: userId,
                  text: fallbackText,
                  blocks
                })
              });
              const json = await res.json();
              if (!json.ok) core.warning(`Slack DM failed to ${userId}: ${JSON.stringify(json)}`);
            }

            function prBlocks(kind, reviewerText) {
              return [
                { type: "header", text: { type: "plain_text", text: kind === 'team' ? "ðŸ‘¥ íŒ€ ë¦¬ë·° ìš”ì²­" : "ðŸ‘€ ê°œì¸ ë¦¬ë·° ìš”ì²­" } },
                {
                  type: "section",
                  fields: [
                    { type: "mrkdwn", text: `*ì œëª©*\n${pr.title}` },
                    { type: "mrkdwn", text: `*ë ˆí¬*\n${context.repo.owner}/${context.repo.repo}` },
                    { type: "mrkdwn", text: `*ìž‘ì„±ìž*\n@${pr.user.login}` },
                    { type: "mrkdwn", text: `*ìš”ì²­ ëŒ€ìƒ*\n${reviewerText}` }
                  ]
                },
                {
                  type: "actions",
                  elements: [
                    { type: "button", text: { type: "plain_text", text: "PR ì—´ê¸°" }, url: pr.html_url }
                  ]
                }
              ];
            }

            async function listTeamMembers(teamSlug) {
              // Use PAT with read:org; fallback to empty
              const token = process.env.ORG_READ_TOKEN;
              if (!token) {
                core.warning('ORG_READ_TOKEN not set; cannot list team members. Provide mapping users.yml for team members.');
                return [];
              }
              const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github+json' };
              let page = 1, per_page = 100, members = [];
              while (true) {
                const url = `https://api.github.com/orgs/${org}/teams/${teamSlug}/members`;
                const data = await httpGet(url, headers, { per_page, page });
                if (!Array.isArray(data) || data.length === 0) break;
                members.push(...data.map(m => m.login));
                if (data.length < per_page) break;
                page++;
              }
              return [...new Set(members)];
            }

            async function resolveSlackIdForGithub(login) {
              const key = String(login).toLowerCase();
              const m = mapByGithub.get(key);
              if (m?.slack) return m.slack;
              if (m?.email) {
                const id = await slackLookupByEmail2(m.email);
                if (id) return id;
              }
              // No mapping
              return null;
            }

            // guard: only on review_requested & not draft
            if (act !== 'review_requested') {
              core.info(`Skip: action=${act}`);
              return;
            }
            if (pr?.draft) {
              core.info('Skip: draft PR');
              return;
            }

            if (requestedReviewer) {
              // individual
              const ghLogin = requestedReviewer.login;
              const slackId = await resolveSlackIdForGithub(ghLogin);
              if (!slackId) {
                core.warning(`No Slack mapping for GitHub user ${ghLogin}`);
                return;
              }
              await slackDM(slackId, prBlocks('individual', `@${ghLogin}`), 'PR review requested (individual)');
              return;
            }

            if (requestedTeam) {
              // team fan-out
              const teamSlug = requestedTeam.slug;
              const ghMembers = await listTeamMembers(teamSlug);

              if (ghMembers.length === 0) {
                core.warning(`Team ${teamSlug} has no members or cannot fetch. Check ORG_READ_TOKEN or provide users.yml mappings.`);
                return;
              }

              // Resolve Slack IDs for each member
              const targets = [];
              for (const login of ghMembers) {
                const slackId = await resolveSlackIdForGithub(login);
                if (slackId) targets.push({ login, slackId });
                else core.warning(`No Slack mapping for team member ${login}`);
              }

              if (targets.length === 0) {
                core.warning('No resolvable Slack IDs for team members.');
                return;
              }

              const textReviewer = `#${teamSlug} (íŒ€ ${targets.length}ëª…)`;
              const blocks = prBlocks('team', textReviewer);
              for (const t of targets) {
                await slackDM(t.slackId, blocks, 'PR review requested (team)');
              }
              return;
            }

            core.info('Nothing to do: neither requested_reviewer nor requested_team present.');
