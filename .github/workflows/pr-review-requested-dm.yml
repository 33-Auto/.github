name: PR Review Requested → Slack DMs (individual & team)

on:
  pull_request:
    types: [review_requested]
  workflow_dispatch: {}   # 수동 테스트 가능

permissions:
  contents: read
  pull-requests: read

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (for users.yml)
        uses: actions/checkout@v4

      - name: Fan-out Slack DMs (with DM channel open)
        uses: actions/github-script@v7
        env:
          ORG: ${{ secrets.ORG }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          ORG_READ_TOKEN: ${{ secrets.ORG_READ_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const { default: fetch } = await import('node-fetch');

            const pr = context.payload.pull_request;
            const act = context.payload.action;
            const requestedReviewer = context.payload.requested_reviewer || null;
            const requestedTeam = context.payload.requested_team || null;
            const org = process.env.ORG || context.repo.owner;

            function loadMapping() {
              const path = '.github/pr-reminder/users.yml';
              if (!fs.existsSync(path)) return { users: [] };
              return yaml.load(fs.readFileSync(path, 'utf8')) || { users: [] };
            }
            const mapping = loadMapping();
            const mapByGithub = new Map(
              (mapping.users || []).map(u => [String(u.github).toLowerCase(), u])
            );

            async function httpGet(url, headers = {}, params = {}) {
              const qs = new URLSearchParams(params);
              const full = qs.toString() ? `${url}?${qs.toString()}` : url;
              const res = await fetch(full, { headers });
              if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
              return await res.json();
            }
            async function httpPost(url, headers = {}, body = {}) {
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json; charset=utf-8', ...headers },
                body: JSON.stringify(body)
              });
              const json = await res.json();
              return json;
            }

            async function slackLookupByEmail(email) {
              if (!email) return null;
              const data = await httpGet(
                'https://slack.com/api/users.lookupByEmail',
                { 'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}` },
                { email }
              );
              if (data.ok && data.user?.id) return data.user.id;
              return null;
            }

            async function openDmChannelForUser(userId) {
              // conversations.open → returns {channel: {id: 'Dxxxx'}}
              const data = await httpPost(
                'https://slack.com/api/conversations.open',
                { 'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}` },
                { users: userId }
              );
              if (!data.ok) {
                core.warning(`conversations.open failed for ${userId}: ${JSON.stringify(data)}`);
                return null;
              }
              return data.channel?.id || null;
            }

            async function slackDMtoUserId(userId, blocks, fallbackText) {
              const dmChannel = await openDmChannelForUser(userId);
              if (!dmChannel) return;
              const resp = await httpPost(
                'https://slack.com/api/chat.postMessage',
                { 'Authorization': `Bearer ${process.env.SLACK_BOT_TOKEN}` },
                { channel: dmChannel, text: fallbackText, blocks }
              );
              if (!resp.ok) core.warning(`chat.postMessage failed: ${JSON.stringify(resp)}`);
            }

            function prBlocks(kind, reviewerText) {
              return [
                { type: "header", text: { type: "plain_text", text: kind === 'team' ? "👥 팀 리뷰 요청" : "👀 개인 리뷰 요청" } },
                {
                  type: "section",
                  "fields": [
                    { type: "mrkdwn", text: `*제목*\n${pr.title}` },
                    { type: "mrkdwn", text: `*레포*\n${context.repo.owner}/${context.repo.repo}` },
                    { type: "mrkdwn", text: `*작성자*\n@${pr.user.login}` },
                    { type: "mrkdwn", text: `*요청 대상*\n${reviewerText}` }
                  ]
                },
                {
                  type: "actions",
                  elements: [
                    { type: "button", text: { type: "plain_text", text: "PR 열기" }, url: pr.html_url }
                  ]
                }
              ];
            }

            async function listTeamMembers(teamSlug) {
              const token = process.env.ORG_READ_TOKEN;
              if (!token) {
                core.warning('ORG_READ_TOKEN not set; cannot list team members.');
                return [];
              }
              const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github+json' };
              let page = 1, per_page = 100, members = [];
              while (true) {
                const url = `https://api.github.com/orgs/${org}/teams/${teamSlug}/members`;
                const data = await httpGet(url, headers, { per_page, page });
                if (!Array.isArray(data) || data.length === 0) break;
                members.push(...data.map(m => m.login));
                if (data.length < per_page) break;
                page++;
              }
              return [...new Set(members)];
            }

            async function resolveSlackIdForGithub(login) {
              const key = String(login).toLowerCase();
              const m = mapByGithub.get(key);
              if (m?.slack) return m.slack;
              if (m?.email) {
                return await slackLookupByEmail(m.email);
              }
              return null;
            }

            // ---- main ----
            core.info(`action=${act}, draft=${pr?.draft}, reviewer=${requestedReviewer?.login || 'null'}, team=${requestedTeam?.slug || 'null'}`);

            if (act !== 'review_requested') { core.info('Skip: not review_requested'); return; }
            if (pr?.draft) { core.info('Skip: draft PR'); return; }

            if (requestedReviewer) {
              const ghLogin = requestedReviewer.login;
              const slackId = await resolveSlackIdForGithub(ghLogin);
              core.info(`individual → gh=${ghLogin}, slack=${slackId || 'N/A'}`);
              if (!slackId) { core.warning(`No Slack mapping for ${ghLogin}`); return; }
              await slackDMtoUserId(slackId, prBlocks('individual', `@${ghLogin}`), 'PR review requested (individual)');
              return;
            }

            if (requestedTeam) {
              const teamSlug = requestedTeam.slug;
              const ghMembers = await listTeamMembers(teamSlug);
              core.info(`team → slug=${teamSlug}, members=${ghMembers.length}`);

              if (ghMembers.length === 0) { core.warning('No team members resolved'); return; }

              const blocks = prBlocks('team', `#${teamSlug} (${ghMembers.length}명)`);
              for (const login of ghMembers) {
                const slackId = await resolveSlackIdForGithub(login);
                core.info(`fan-out → gh=${login}, slack=${slackId || 'N/A'}`);
                if (!slackId) { core.warning(`No Slack mapping for ${login}`); continue; }
                await slackDMtoUserId(slackId, blocks, 'PR review requested (team)');
              }
              return;
            }

            core.info('Nothing to do: neither individual nor team reviewer present.');
