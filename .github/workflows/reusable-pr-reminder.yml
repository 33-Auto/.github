name: Reusable PR Reminder Logic

# Îã§Î•∏ ÏõåÌÅ¨ÌîåÎ°úÏö∞ÏóêÏÑú Ìò∏Ï∂úÎê† Ïàò ÏûàÎèÑÎ°ù ÏÑ§Ï†ï
on:
  workflow_call:
    inputs:
      SLACK_USER_MAP:
        required: true
        type: string
    secrets:
      SLACK_WEBHOOK_URL: # Ìò∏Ï∂úÌïòÎäî Ï™ΩÏóêÏÑú Slack Webhook URLÏùÑ Ï†ÑÎã¨Î∞õÏùå
        required: true

jobs:
  remind:
    runs-on: ubuntu-latest
    steps:
      - name: Î¶¨Î∑∞ ÏäπÏù∏Ïù¥ ÎêòÏßÄ ÏïäÏùÄ PR Î™©Î°ù Ï°∞Ìöå Î∞è Slack ÏïåÎ¶º
        uses: actions/github-script@v7
        with:
          script: |
            // --- [Î°úÍ∑∏ Ï∂îÍ∞Ä 1] ---
            // ÏõåÌÅ¨ÌîåÎ°úÏö∞Í∞Ä GitHub Î≥ÄÏàòÎ°úÎ∂ÄÌÑ∞ Î∞õÏùÄ ÏõêÎ≥∏ SLACK_USER_MAP Î¨∏ÏûêÏó¥ÏùÑ Ï∂úÎ†•ÌïúÎã§.
            // Ïù¥ Í∞íÏù¥ ÎπÑÏñ¥ÏûàÍ±∞ÎÇò '{}' ÎùºÎ©¥ Î≥ÄÏàòÍ∞Ä Ï†úÎåÄÎ°ú Ï†ÑÎã¨ÎêòÏßÄ ÏïäÏùÄ Í≤ÉÏù¥Îã§.
            const rawSlackUserMap = '${{ secrets.SLACK_USER_MAP || '{}' }}';
            console.log(`[DEBUG] Received SLACK_USER_MAP string: ${rawSlackUserMap}`);

            const slackUserMap = JSON.parse(rawSlackUserMap);
            
            // --- [Î°úÍ∑∏ Ï∂îÍ∞Ä 2] ---
            // JSON ÌååÏã± ÌõÑ ÏÉùÏÑ±Îêú ÏûêÎ∞îÏä§ÌÅ¨Î¶ΩÌä∏ Í∞ùÏ≤¥Î•º Ï∂úÎ†•ÌïúÎã§.
            console.log('[DEBUG] Parsed slackUserMap object:', slackUserMap);

            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const prsToRemind = [];
            const repoName = context.repo.repo;

            for (const pr of prs) {
              if (pr.draft || pr.labels.some(label => label.name === 'do-not-remind')) {
                continue;
              }
              
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: repoName,
                pull_number: pr.number,
              });

              const approvingReviewers = new Set();
              reviews.forEach(review => {
                if (review.state === 'APPROVED') {
                  approvingReviewers.add(review.user.login);
                }
              });

              const approvalCount = approvingReviewers.size;

              if (approvalCount < 3) {
                const prInfo = {
                  ...pr,
                  approvalCount: approvalCount,
                  approvers: Array.from(approvingReviewers),
                  reviewers: pr.requested_reviewers.map(r => r.login),
                };

                // --- [Î°úÍ∑∏ Ï∂îÍ∞Ä 3] ---
                // ÏïåÎ¶º ÎåÄÏÉÅÏù¥ Îê† Í∞Å PRÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï∂úÎ†•ÌïúÎã§.
                // ÌäπÌûà prInfo.reviewersÏóê Î¶¨Î∑∞ ÏöîÏ≤≠Ïûê Î™©Î°ùÏù¥ Ïò¨Î∞îÎ•¥Í≤å Îì§Ïñ¥ÏûàÎäîÏßÄ ÌôïÏù∏ÌïúÎã§.
                console.log(`\n[DEBUG] Processing PR #${pr.number}: ${pr.title}`);
                console.log(` -> Reviewers requested: ${JSON.stringify(prInfo.reviewers)}`);

                prsToRemind.push(prInfo);
              }
            }

            if (prsToRemind.length > 0) {
              const blocks = [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üîî Î¶¨Î∑∞ ÏäπÏù∏Ïù¥ Îçî ÌïÑÏöîÌï©ÎãàÎã§!"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": `ÌòÑÏû¨ *${prsToRemind.length}Í∞ú*Ïùò PRÏù¥ Î¶¨Î∑∞Î•º Í∏∞Îã§Î¶¨Í≥† ÏûàÏäµÎãàÎã§.`
                    }
                  ]
                },
                {
                  "type": "divider"
                }
              ];

              for (const pr of prsToRemind) {
                const approverText = pr.approvers.length > 0 ? pr.approvers.join(', ') : 'ÏóÜÏùå';
                
                const reviewerMentions = pr.reviewers.map(reviewer => {
                  const slackUserId = slackUserMap[reviewer];
                  
                  // --- [Î°úÍ∑∏ Ï∂îÍ∞Ä 4] ---
                  // Í∞Å Î¶¨Î∑∞Ïñ¥Ïóê ÎåÄÌï¥ Îß§ÌïëÏù¥ Ïñ¥ÎñªÍ≤å Ïù¥Î£®Ïñ¥ÏßÄÎäîÏßÄ ÏÉÅÏÑ∏Ìûà Ï∂úÎ†•ÌïúÎã§.
                  // "Found mapping" ÎòêÎäî "Mapping NOT found" Î°úÍ∑∏Î•º ÌÜµÌï¥ Îß§Ìïë ÏÑ±Í≥µ Ïó¨Î∂ÄÎ•º ÌôïÏù∏Ìï† Ïàò ÏûàÎã§.
                  if (slackUserId) {
                    console.log(` -> Mapping for '${reviewer}': Found. Slack ID: ${slackUserId}`);
                  } else {
                    console.log(` -> Mapping for '${reviewer}': NOT found. Using GitHub ID.`);
                  }
                  
                  return slackUserId ? `<@${slackUserId}>` : reviewer;
                }).join(', ');

                const reviewerText = reviewerMentions.length > 0 ? reviewerMentions : 'ÏßÄÏ†ïÎêòÏßÄ ÏïäÏùå';

                blocks.push({
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": `*<${pr.html_url}|[${repoName}] #${pr.number} ${pr.title}>*`
                  }
                });
                blocks.push({
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": `*ÏäπÏù∏ ÌòÑÌô©:*\n${pr.approvalCount}/3` },
                    { "type": "mrkdwn", "text": `*ÏûëÏÑ±Ïûê:*\n${pr.user.login}` },
                    { "type": "mrkdwn", "text": `*ÏäπÏù∏Ìïú Î¶¨Î∑∞Ïñ¥:*\n${approverText}` },
                    { "type": "mrkdwn", "text": `*Î¶¨Î∑∞ ÏöîÏ≤≠:*\n${reviewerText}` }
                  ]
                });
                blocks.push({ "type": "divider" });
              }

              const slackWebhookUrl = "${{ secrets.SLACK_WEBHOOK_URL }}";
              await fetch(slackWebhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ blocks: blocks }),
              });
            } else {
              console.log("No PRs needing more approvals found.");
            }
