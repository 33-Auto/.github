name: Reusable PR Reminder Logic

# ë‹¤ë¥¸ ì›Œí¬í”Œë¡œìš°ì—ì„œ í˜¸ì¶œë  ìˆ˜ ìˆë„ë¡ ì„¤ì •
on:
  workflow_call:
    secrets:
      SLACK_WEBHOOK_URL: # í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œ Slack Webhook URLì„ ì „ë‹¬ë°›ìŒ
        required: true
      ORGANIZATION_TOKEN:
        description: "PAT with read:org (ë° í•„ìš” ì‹œ repo ê¶Œí•œ)"
        required: true

jobs:
  remind:
    runs-on: ubuntu-latest
    steps:
      - name: ë¦¬ë·° ìŠ¹ì¸ì´ ë˜ì§€ ì•Šì€ PR ëª©ë¡ ì¡°íšŒ ë° Slack ì•Œë¦¼
        uses: actions/github-script@v7
        with:
          # í˜¸ì¶œìê°€ ì „ë‹¬í•œ ì‹œí¬ë¦¿ì„ ì—¬ê¸°ì„œ ì‚¬ìš©í•œë‹¤.
          github-token: ${{ secrets.ORGANIZATION_TOKEN }}
          script: |
            // 1) ì˜¤í”ˆëœ PR ëª©ë¡ ì¡°íšŒ
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const stalePrs = [];
            const now = new Date();

            for (const pr of prs) {
              // ë“œë˜í”„íŠ¸ì´ê±°ë‚˜ 'do-not-remind' ë¼ë²¨ì´ ë¶™ì€ PRì€ ê±´ë„ˆëœ€
              if (pr.draft || pr.labels.some(label => label.name === 'do-not-remind')) {
                continue;
              }

              const prDate = new Date(pr.created_at);
              const hoursSinceCreation = (now - prDate) / (1000 * 60 * 60);

              // 24ì‹œê°„ ì´ìƒ ì§€ë‚œ PRë§Œ ëŒ€ìƒìœ¼ë¡œ í•¨
              if (hoursSinceCreation < 24) {
                continue;
              }
              
              // --- í•µì‹¬ ë³€ê²½ ë¡œì§ ì‹œì‘ ---
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
              });

              // 'APPROVED' ìƒíƒœì˜ ë¦¬ë·°ë¥¼ ë‚¨ê¸´ ê³ ìœ í•œ ìœ ì € ëª©ë¡ì„ ë§Œë“ ë‹¤
              const approvingReviewers = new Set();
              reviews.forEach(review => {
                if (review.state === 'APPROVED') {
                  approvingReviewers.add(review.user.login);
                }
              });

              const approvalCount = approvingReviewers.size;

              // ìŠ¹ì¸ ìˆ˜ê°€ 3ëª… ë¯¸ë§Œì¸ ê²½ìš°ì—ë§Œ ë¦¬ë§ˆì¸ë” ëª©ë¡ì— ì¶”ê°€
              if (approvalCount < 3) {
                // ë©”ì‹œì§€ì— í˜„ì¬ ìŠ¹ì¸ ìˆ˜ë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ê°ì²´ì— ì¶”ê°€
                pr.approvalCount = approvalCount; 
                stalePrs.push(pr);
              }
              // --- í•µì‹¬ ë³€ê²½ ë¡œì§ ë ---
            }

            // ë¦¬ë§ˆì¸ë“œê°€ í•„ìš”í•œ PRì´ ìˆì„ ê²½ìš° Slack ë©”ì‹œì§€ ì „ì†¡
            if (stalePrs.length > 0) {
              let message = `ğŸ”” *ë¦¬ë·° ìŠ¹ì¸ì´ ë” í•„ìš”í•©ë‹ˆë‹¤!* (í˜„ì¬ ${stalePrs.length}ê°œ PR ëŒ€ê¸°ì¤‘)\n`;
              for (const pr of stalePrs) {
                // ë©”ì‹œì§€ì— í˜„ì¬ ìŠ¹ì¸ í˜„í™©ì„ í¬í•¨ (ì˜ˆ: ìŠ¹ì¸: 1/3)
                message += `\n- <${pr.html_url}|#${pr.number} ${pr.title}> (ìŠ¹ì¸: ${pr.approvalCount}/3)`;
              }

              const slackWebhookUrl = "${{ secrets.SLACK_WEBHOOK_URL }}";
              await fetch(slackWebhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: message }),
              });
            } else {
              console.log("No stale PRs needing more approvals found.");
            }
