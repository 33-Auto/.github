name: Reusable PR Reminder Logic

on:
  workflow_call:
    inputs:
      SLACK_USER_MAP:
        required: true
        type: string
    secrets:
      SLACK_WEBHOOK_URL:
        required: true

jobs:
  remind:
    runs-on: ubuntu-latest
    steps:
      - name: ë¦¬ë·° ìŠ¹ì¸ì´ ë˜ì§€ ì•Šì€ PR ëª©ë¡ ì¡°íšŒ ë° Slack ì•Œë¦¼
        uses: actions/github-script@v7
        # ì…ë ¥ê°’ì„ envë¡œ ì „ë‹¬í•˜ë©´ JSì—ì„œ ì•ˆì „í•˜ê²Œ ì½ì„ ìˆ˜ ìˆìŒ
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_USER_MAP: ${{ inputs.SLACK_USER_MAP }}
        with:
          script: |
            // envë¡œ ì „ë‹¬ëœ ë¬¸ìì—´ì„ ê°€ì ¸ì™€ì„œ JSON íŒŒì‹±
            const rawSlackUserMap = process.env.SLACK_USER_MAP || '{}';
            let slackUserMap = {};
            try {
              slackUserMap = JSON.parse(rawSlackUserMap);
            } catch (err) {
              console.log('[WARN] Invalid SLACK_USER_MAP, fallback to empty object.');
              slackUserMap = {};
            }
            console.log('[DEBUG] Parsed slackUserMap object:', slackUserMap);

            // ì˜¤í”ˆëœ PR ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            const prsToRemind = [];
            const repoName = context.repo.repo;

            for (const pr of prs) {
              if (pr.draft || pr.labels.some(label => label.name === 'do-not-remind')) continue;

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: repoName,
                pull_number: pr.number,
              });

              const approvingReviewers = new Set();
              reviews.forEach(review => {
                if (review.state === 'APPROVED') approvingReviewers.add(review.user.login);
              });

              const approvalCount = approvingReviewers.size;

              if (approvalCount < 3) {
                const prInfo = {
                  ...pr,
                  approvalCount,
                  approvers: Array.from(approvingReviewers),
                  reviewers: pr.requested_reviewers.map(r => r.login),
                };

                console.log(`\n[DEBUG] Processing PR #${pr.number}: ${pr.title}`);
                console.log(` -> Reviewers requested: ${JSON.stringify(prInfo.reviewers)}`);

                prsToRemind.push(prInfo);
              }
            }

            if (prsToRemind.length === 0) {
              console.log('No PRs needing more approvals found.');
              return;
            }

            // Slack ë©”ì‹œì§€ ë¸”ë¡ ìƒì„±
            const blocks = [
              { type: 'header', text: { type: 'plain_text', text: 'ğŸ”” ë¦¬ë·° ìŠ¹ì¸ì´ ë” í•„ìš”í•©ë‹ˆë‹¤!' } },
              {
                type: 'context',
                elements: [
                  { type: 'mrkdwn', text: `í˜„ì¬ *${prsToRemind.length}ê°œ*ì˜ PRì´ ë¦¬ë·°ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤.` }
                ],
              },
              { type: 'divider' },
            ];

            for (const pr of prsToRemind) {
              const approverText = pr.approvers.length ? pr.approvers.join(', ') : 'ì—†ìŒ';

              const reviewerMentions = pr.reviewers
                .map(reviewer => {
                  const slackUserId = slackUserMap[reviewer];
                  if (slackUserId) {
                    console.log(` -> Mapping for '${reviewer}': Found. Slack ID: ${slackUserId}`);
                  } else {
                    console.log(` -> Mapping for '${reviewer}': NOT found. Using GitHub ID.`);
                  }
                  return slackUserId ? `<@${slackUserId}>` : reviewer;
                })
                .join(', ');

              const reviewerText = reviewerMentions.length ? reviewerMentions : 'ì§€ì •ë˜ì§€ ì•ŠìŒ';

              blocks.push(
                { type: 'section', text: { type: 'mrkdwn', text: `*<${pr.html_url}|[${repoName}] #${pr.number} ${pr.title}>*` } },
                {
                  type: 'section',
                  fields: [
                    { type: 'mrkdwn', text: `*ìŠ¹ì¸ í˜„í™©:*\n${pr.approvalCount}/3` },
                    { type: 'mrkdwn', text: `*ì‘ì„±ì:*\n${pr.user.login}` },
                    { type: 'mrkdwn', text: `*ìŠ¹ì¸í•œ ë¦¬ë·°ì–´:*\n${approverText}` },
                    { type: 'mrkdwn', text: `*ë¦¬ë·° ìš”ì²­:*\n${reviewerText}` },
                  ],
                },
                { type: 'divider' }
              );
            }

            // Slackì— ì•Œë¦¼ ì „ì†¡
            await fetch(process.env.SLACK_WEBHOOK_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ blocks }),
            });
